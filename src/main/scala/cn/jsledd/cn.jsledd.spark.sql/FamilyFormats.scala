package cn.jsledd.cn.jsledd.spark.sql

import scala.util.control.NonFatal
import shapeless._
import shapeless.labelled._
import shapeless.ops.hlist.Length
import shapeless.ops.nat.ToInt
import org.apache.spark.sql.Row
import org.apache.spark.sql.types.{StructField, StructType}
import sql.Show

/**
  * Implicit functions to generate a [[RowFormat]] for any type with a [[Generic]] representation, like a case class.
  *
  * @author upio
  */
trait FamilyFormats extends Serializable {

  /**
    * Terminal case of the HList traversal
    *
    * @return wrapped row format for HNil
    * @tparam W the wrapped type of the Product
    */
  implicit def hnilFormat[W: ProductLength]: WrappedRowFormat[W, HNil] = new WrappedRowFormat[W, HNil] {
    val schema = Nil
    val depth = -1 // start at -1 so the last element has depth 0

    // The array is initialized here and only mutated by those generated by the hlistFormat
    def write(t: HNil): Array[Any] = new Array[Any](productLength[W])

    def read(row: Row): HNil = HNil
  }

  /**
    * Recursive function which materializes a [[WrappedRowFormat]] for each element in a Product
    *
    * @param fieldName name of the field
    * @param columnFormat for the type of this field
    * @param tailFormat format for the remaining fields
    * @tparam W wrapped type of the original Product
    * @tparam V type of the field at this point in the traversal
    * @tparam Key type alias of the symbol representing the name of this field. We only need it
    *             for implicitly resolving a Witness to it
    * @tparam R HList of elements remaining in the traversal
    */
  implicit def hlistFormat[W: ProductLength, V, Key <: Symbol, R <: HList](implicit
    fieldName: Witness.Aux[Key],
    columnFormat: ColumnFormat[V],
    tailFormat: WrappedRowFormat[W, R]): WrappedRowFormat[W, FieldType[Key, V] :: R] = new WrappedRowFormat[W, FieldType[Key, V] :: R] {

    // determine the schema of the entire Product by appending this entries column schema to the children schemas list
    // a stack is used to preserve order of the Product
    val schema = StructField(fieldName.value.name, columnFormat.dataType, columnFormat.isInstanceOf[OptionColumnFormat[_]]) :: tailFormat.schema
    val depth = tailFormat.depth + 1
    // depth is not the correct index. We need to subtract it from the length of the Product to preserve schema order
    val index = productLength[W] - depth - 1

    def write(t: FieldType[Key, V] :: R): Array[Any] = {
      val tailArray = tailFormat.write(t.tail)
      tailArray(index) = columnFormat.write(t.head)
      tailArray
    }

    def read(row: Row): FieldType[Key, V] :: R = {
      val value = columnFormat.read(row.get(index))
      field[Key](value) :: tailFormat.read(row)
    }
  }

  /**
    * Materializes a RowFormat for any Product by recursively materializing a WrappedRowFormat
    * chain for all individual fields.
    *
    * @param gen labelled generic for the Product. It gives us access to the generic
    *            representation of the product required for the hlistFormat traversal
    * @param format resolved WrappedRowFormat chain for the Product
    * @tparam T type of the Product
    * @tparam Repr generic (HList) representation of the Product
    * @return a materialized RowFormat for the Product
    */
  implicit def anyProductAdapter[T <: Product, Repr](implicit
    gen: LabelledGeneric.Aux[T, Repr],
    format: WrappedRowFormat[T, Repr]): RowFormat[T] = new RowFormat[T] {

    val schema = StructType(format.schema.toArray)

    // TODO: Optimize away the copy of the Array to another Array within the Row
    def write(t: T): Row = Row.fromSeq(format.write(gen.to(t)))

    def read(row: Row): T =
      try gen.from(format.read(row))
      catch {
        case NonFatal(ex) => throw RowDeserializationException(s"Expected $schema, got $row", ex)
      }
  }

  /**
    * Extract the length (number of fields) of a Product
    *
    * TODO: This only exists to simplify other methods which require the length. Is there a cleaner way in Shapeless?
    *
    * @param generic representation of the Product T
    * @param genericLength computed length of the generic representation of T
    * @param toInt mapping function to materialize the Product length from genericLength
    * @tparam T type of the Product
    * @tparam Repr generic representation of the Product
    * @tparam NatRepr type of the natural number representing the length, in this case Int
    * @return ProductLength storing the materialized value
    */
  implicit def computeProductLength[T, Repr <: HList, NatRepr <: Nat](implicit
    generic: Generic.Aux[T, Repr],
    genericLength: Length.Aux[Repr, NatRepr],
    toInt: ToInt[NatRepr]): ProductLength[T] = ProductLength(toInt.apply())

}

object FamilyFormats extends FamilyFormats

// this trait is used internally to maintain the original type W with its generic representation Repr
trait WrappedRowFormat[W, Repr] extends Serializable {
  val depth: Int

  val schema: List[StructField]

  def write(repr: Repr): Array[Any]

  def read(row: Row): Repr
}

/**
  * Case class for storing the computed length (number of fields) of a Product during implicit resolution
  *
  * TODO: Is there a clean way to do this with Shapeless?
  *
  * @param value length of the Product
  * @tparam T product type
  */
final case class ProductLength[T](value: Int)
